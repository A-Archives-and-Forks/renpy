#!/usr/bin/env python3

import re
import ast
import sys
import pathlib
import textwrap
import inspect
import types
import builtins
import json
from typing import TextIO

ROOT = pathlib.Path(__file__).parent.parent.resolve()
sys.path.insert(0, str(ROOT))

GENERATED_BY_SCRIPT = "# Generated by scripts/generate_pyi.py, do not edit."


class StringifyAnnotations(ast.NodeVisitor):
    @staticmethod
    def _maybe_string(node: ast.expr):

        as_str = ast.unparse(node)
        if as_str in builtins.__dict__:
            return ast.parse(as_str, mode="eval").body

        return ast.Constant(as_str)

    def visit_FunctionDef(self, node):
        if node.returns is not None:
            node.returns = self._maybe_string(node.returns)

        self.generic_visit(node)

    def visit_AsyncFunctionDef(self, node):
        if node.returns is not None:
            node.returns = self._maybe_string(node.returns)

        self.generic_visit(node)

    def visit_arg(self, node):
        if node.annotation is not None:
            node.annotation = self._maybe_string(node.annotation)

        self.generic_visit(node)

    def visit_AnnAssign(self, node):
        if node.annotation is not None:
            node.annotation = self._maybe_string(node.annotation)

        self.generic_visit(node)


def stringify_annotations(code: str) -> str:
    """
    Given a string of code return a string of code with all annotations
    converted to strings, so forward references works.
    """

    tree = ast.parse(code, "<code>")
    StringifyAnnotations().visit(tree)
    return ast.unparse(tree)


def python_signature(o: object) -> str | None:
    """
    Given a callable object, try to return a python-style type signature.
    Returns the signature as a string if it can be determined, or None if
    no signature can be determined.

    This function assumes Cython was compiled with `embedsignature=True` and
    `embedsignature.format=python`, and uses inspect.signature as a fallback.
    """

    if not callable(o):
        return None

    # First, look at embedded signature.
    doc = getattr(o, "__doc__", None)
    sig_line = None
    if isinstance(doc, str):
        if m := re.match(rf"{o.__name__}\(.*\)(?: -> .*)?", doc):
            sig_line = m[0]

    # Now convert this function into Python function with stringyfied type
    # annotations, so forward references works.
    if sig_line is not None:
        sig_line = stringify_annotations(f"def {sig_line}: pass")

        # Fix 'void' return type to 'None'.
        sig_line = sig_line.replace("'void'", "None")

        return re.match(rf"def {o.__name__}(\(.*\)(?: -> .*)?):", sig_line).group(1)

    # If for some reason there is no embedded signature, at least get param names.
    try:
        return str(inspect.signature(o))
    except Exception:
        return None


def generate_namespace(out: TextIO, prefix: str, namespace: types.ModuleType | type):
    """
    This generates type information for a module or class namespace.
    """

    namespace_items = sorted(namespace.__dict__.items())
    is_module = isinstance(namespace, types.ModuleType)

    generated = False
    missing_types = set(i[0] for i in namespace_items)

    # Imports.
    for k, v in namespace_items:
        if not isinstance(v, types.ModuleType):
            continue

        name = v.__name__

        if is_module and name == f"{namespace.__name__}.{k}":
            out.write(prefix + f"from . import {k}\n")
        else:
            out.write(prefix + f"import {name} as {k}\n")

        generated = True
        missing_types.discard(k)

    out.write("\n")

    # Classes, methods, and functions.
    for k, v in namespace_items:
        if k in ("__new__", "__init__", "__reduce_cython__", "__setstate_cython__") or k.startswith("__pyx"):
            missing_types.discard(k)
            continue

        if isinstance(v, type):
            if v.__module__ != namespace.__name__:
                if v.__module__.startswith("renpy"):
                    out.write(prefix + f"{k} = {v.__module__}.{v.__name__}\n")
                else:
                    out.write(prefix + f"from {v.__module__} import {v.__name__}\n")
                out.write("\n")
                generated = True
                missing_types.discard(k)
                continue

            # Alias in the same module.
            if k != v.__name__:
                out.write(prefix + f"{k} = {v.__name__}\n")
                out.write("\n")
                generated = True
                missing_types.discard(k)
                continue

            # Bases and class name.
            bases: list[str] = []
            for i in v.__bases__:
                if i is object:
                    pass
                elif i.__module__ == "builtins":
                    bases.append(i.__name__)
                elif i.__module__ == namespace.__name__:
                    bases.append(i.__name__)
                else:
                    bases.append(f"{i.__module__}.{i.__name__}")

            if bases:
                bases_clause = f"({', '.join(bases)})"
            else:
                bases_clause = ""

            out.write(prefix + f"class {v.__name__}{bases_clause}:\n")

            # Figure out the signature for init.
            init_sig = python_signature(v)

            if init_sig is None and "__init__" in v.__dict__:
                init_sig = python_signature(v.__init__)

            if init_sig is not None:
                if "(self" not in init_sig:
                    print(f"Warning: missing self in {v.__name__}.__init__: {init_sig}")
                    init_sig = re.sub(r"\(", "(self, ", init_sig, 1)

                out.write(prefix + f"    def __init__{init_sig}: ...\n")

            # Methods and other contents.
            generate_namespace(out, prefix + "    ", v)
            out.write("\n")

            generated = True
            missing_types.discard(k)
            continue

        if not callable(v):
            continue

        sig = python_signature(v)
        if sig is None:
            continue

        if not is_module:
            if "(cls" in sig:
                out.write(prefix + "@classmethod\n")
            elif "(self" not in sig:
                out.write(prefix + "@staticmethod\n")

        out.write(prefix + f"def {k}{sig}: ...\n")
        out.write("\n")

        generated = True
        missing_types.discard(k)

    # _types declaration.
    _types = getattr(namespace, "_types", "")
    _types = textwrap.dedent(_types.strip("\n"))
    missing_types.discard("_types")

    if _types:
        _types = stringify_annotations(_types)
        out.write(textwrap.indent(_types, prefix))
        out.write("\n")
        generated = True

        mod = ast.parse(_types, mode="exec")
        for i in mod.body:
            if not isinstance(i, ast.AnnAssign):
                print(f"Unexpected node in _types: {i!r}")
                continue

            if not isinstance(i.target, ast.Name):
                print(f"Unexpected target in _types: {i.target!r}")
                continue

            missing_types.discard(i.target.id)

    # Explicitly annotated types.
    for k, v in inspect.get_annotations(namespace).items():
        out.write(prefix + f"{k}: {v}\n")
        generated = True
        missing_types.discard(k)

    # Integer variables.
    for k, v in namespace_items:
        if k in missing_types and isinstance(v, int):
            out.write(prefix + f"{k}: int\n")
            generated = True
            missing_types.discard(k)

    if not generated:
        out.write(prefix + "pass\n\n")

    missing_types = {i for i in missing_types if not (i.startswith("__") and i.endswith("__"))}
    if missing_types:
        if is_module:
            where = f"module {namespace.__name__}"
        else:
            where = f"class {namespace.__qualname__}"

        comma_names = ", ".join(f"'{i}'" for i in missing_types)
        print(f"In {where}, missing type annotations for: {comma_names}")
        print("Consider adding them to _types, or fixing signatures.")


def generate_module(module: types.ModuleType, package: bool):
    """
    This generates type information for a module.
    """

    if module.__name__.startswith("renpy."):
        base = ROOT
    else:
        base = ROOT / "typings"

    modfn = module.__name__.replace(".", "/")

    if package:
        fn = base / modfn / "__init__.pyi"
    else:
        fn = base / f"{modfn}.pyi"

    if fn.exists() and fn.open(encoding="utf-8").read(len(GENERATED_BY_SCRIPT)) != GENERATED_BY_SCRIPT:
        return

    print(f"Generating {fn.relative_to(ROOT).as_posix()}")

    fn.parent.mkdir(parents=True, exist_ok=True)

    with fn.open("w", encoding="utf-8") as f:
        print(GENERATED_BY_SCRIPT, file=f)
        print(file=f)

        print("from typing import Any, Callable", file=f)
        print(file=f)
        print("import renpy", file=f)
        print(file=f)
        generate_namespace(f, "", module)

    return fn


def is_extension(m: types.ModuleType):
    """
    Returns true if m is an extension module, and False otherwise.
    """

    if m.__file__ == "built-in":
        return True

    if m.__file__.endswith((".so", ".pyd")):
        return True

    return False


def should_generate(name: str, m: object):
    """
    Returns true if we should generate the type information for the module with
    `name`.
    """

    if not isinstance(m, types.ModuleType):
        return False

    prefix = name.partition(".")[0]

    if prefix == "renpy":
        return is_extension(m)

    return name in ["_renpy", "_renpybidi"]


def manage_gitignore(generated_files: list[str]):
    gitignore = ROOT / ".gitignore"

    old_lines = gitignore.read_text().split("\n")
    new_lines = []

    for line in old_lines:
        if line.endswith(".pyi"):
            continue

        new_lines.append(line)

        if line == "# Pyi Files (generated by scripts/generate_pyi.py)":
            new_lines.extend(generated_files)

    gitignore.write_text("\n".join(new_lines))


def manage_vscode(generated_files: list[str]):
    settings = ROOT / ".vscode" / "settings.json"

    with open(settings) as f:
        j = json.load(f)

    files_exclude = j["files.exclude"]

    files_exclude = {k: v for k, v in files_exclude.items() if not k.endswith(".pyi")}

    files_exclude |= dict.fromkeys(generated_files, True)

    j["files.exclude"] = files_exclude

    with open(settings, "w") as f:
        json.dump(j, f, indent=4)


def main():
    import _renpy as _renpy
    import _renpybidi as _renpybidi
    import renpy

    renpy.import_all()

    packages: set[str] = set()

    for name in tuple(sys.modules):
        package = name.rpartition(".")[0]
        packages.add(package)

    generated_files: list[str] = []

    for name, mod in sorted(sys.modules.items()):
        if not should_generate(name, mod):
            continue

        p = generate_module(mod, name in packages)
        if p is not None:
            p = p.relative_to(ROOT)
            if p.parts[0] == "renpy":
                generated_files.append(p.as_posix())

    generated_files.sort()

    manage_gitignore(generated_files)
    manage_vscode(generated_files)

    for fn in (ROOT / "scripts" / "pyi").glob("**/*.pyi"):
        dfn = ROOT / "typings" / fn.relative_to(ROOT / "scripts" / "pyi")
        text = fn.read_text()
        dfn.parent.mkdir(parents=True, exist_ok=True)
        dfn.write_text(text)


if __name__ == "__main__":
    main()
